---
title: "Untitled"
output: html_document
---

```{r,message=FALSE, warning=FALSE, results='hide' }
library(presto)
library(sceptre)
library(sceptredata)
library(readr)
library(dplyr)
library(Matrix)
```

```{r, message=FALSE, warning=FALSE, results='hide'}
Morris_data <- T


if (Morris_data) {
  directories <- "data/STINGseq-v1_GDO"
  grna_target_data_frame <- data.frame(read_csv(paste0(directories,"/grna_target_data_frame.csv")))
  sceptre_object <- import_data_from_cellranger(
  directories = directories,
  moi = "high",
  grna_target_data_frame = grna_target_data_frame
)
} else {
  directories <- paste0(system.file("extdata", package = "sceptredata"), "/highmoi_example/gem_group_", 1:2)
  data(grna_target_data_frame_highmoi)
  sceptre_object <- import_data_from_cellranger(
  directories = directories,
  moi = "high",
  grna_target_data_frame = grna_target_data_frame_highmoi
)
}


positive_control_pairs <- construct_positive_control_pairs(sceptre_object)

discovery_pairs_cis <- construct_cis_pairs(
  sceptre_object = sceptre_object,
  positive_control_pairs = positive_control_pairs,
  response_position_data_frame=gene_position_data_frame_grch37,
  distance_threshold = 5e5
)

discovery_pairs_trans <- construct_trans_pairs(
  sceptre_object = sceptre_object,
  positive_control_pairs = positive_control_pairs,
  pairs_to_exclude = "pairs_containing_pc_targets"
)
sceptre_object <- sceptre_object |> # |> is R's base pipe, similar to %>%
  set_analysis_parameters(
    discovery_pairs=discovery_pairs_trans, 
    positive_control_pairs=positive_control_pairs, 
    side="both") |>
  assign_grnas()
```

```{r}
str(sceptre_object)
```

```{r}
grna_assignment_matrix <- get_grna_assignments(
  sceptre_object = sceptre_object
)
```

```{r}
discovery_pairs<- discovery_pairs_trans
```

```{r}
discovery_pairs
```

## Modifying and overwrite the functions in Presto library

```{r}
compute_ustat <- function(Xr, cols_list, n1n2_list, group_size_list) {
  total_loops <- length(cols_list) # Total number of loops
  loop_counter <- 1 # Initialize loop counter
  
  mapply(function(cols, n1n2, group_size) {
    cat("Compute wilcox test statisitcs for gRNA #", loop_counter, "of", total_loops,".    ", round(loop_counter / total_loops * 100, 2)
,"% of total progress" , "\n") 
    loop_counter <<- loop_counter + 1 # Increment the counter
    
    grs <- sumGroups(Xr, cols)
    
    if (is(Xr, "dgCMatrix")) {
      gnz <- (group_size - nnzeroGroups(Xr, cols))
      zero_ranks <- (nrow(Xr) - diff(Xr@p) + 1) / 2
      ustat <- t((t(gnz) * zero_ranks)) + grs - group_size * (group_size + 1) / 2
    } else {
      ustat <- grs - group_size * (group_size + 1) / 2
    }
    
    return(ustat)
  }, cols_list, n1n2_list, group_size_list, SIMPLIFY = FALSE)
}



compute_pval <- function(ustat_list, ties, N, n1n2_list) {
  total_loops <- length(ustat_list) # Total number of loops
  loop_counter <- 1 # Initialize loop counter
  mapply(function(ustat, n1n2) {
    cat("Compute wilcox p value for gRNA #", loop_counter, "of", total_loops,".    ", round(loop_counter / total_loops * 100, 2)
,"% of total progress" , "\n") 
    loop_counter <<- loop_counter + 1 # Increment the counter
    z <- ustat - 0.5 * n1n2
    z <- z - sign(z) * 0.5
    .x1 <- N ^ 3 - N
    .x2 <- 1 / (12 * (N^2 - N))
    
    rhs <- lapply(ties, function(tvals) {
      (.x1 - sum(tvals ^ 3 - tvals)) * .x2
    }) %>% unlist
    
    usigma <- sqrt(matrix(n1n2, ncol = 1) %*% matrix(rhs, nrow = 1))
    z <- t(z / usigma)
    
    pvals <- matrix(2 * pnorm(-abs(as.numeric(z))), ncol = ncol(z))
    return(pvals)
  }, ustat_list, n1n2_list, SIMPLIFY = FALSE)
}



tidy_results_reduced <- function(wide_res, features, groups) {
  res <- Reduce(cbind, lapply(wide_res, as.numeric)) %>% data.frame()
  colnames(res) <- names(wide_res)
  
  # Create the 'feature' and 'group' columns
  res$feature <- rep(features, times = length(groups))
  res$group <- rep(groups, each = length(features))
  
  # Filter only the first group
  first_group <- groups[1]
  res <- res %>% dplyr::filter(group == first_group)
  
  # Select the relevant columns
  res %>% dplyr::select(
    .data$feature,
    .data$statistic,
    .data$pval
  )
}


wilcoxauc <- function(X, ...) {
    UseMethod("wilcoxauc")
}

wilcoxauc.default <- function(X, y, groups_use = NULL, verbose = TRUE, ...) {
    ## Check and possibly correct input values
    if (is(X, "dgeMatrix")) X <- as.matrix(X)
    if (is(X, "data.frame")) X <- as.matrix(X)
    if (is(X, "dgTMatrix")) X <- as(X, "dgCMatrix")
    if (is(X, "TsparseMatrix")) X <- as(X, "dgCMatrix")
    if (ncol(X) != length(y[[1]])) stop("number of columns of X does not
                                match length of y")
    if (!is.null(groups_use)) {
        idx_use <- which(y %in% intersect(groups_use, y))
        y <- y[idx_use]
        X <- X[, idx_use]
    }

    y  <- lapply(y, factor)
  

    group.size <- lapply(y, function(vec) as.numeric(table(vec)))
  

    if (is.null(row.names(X))) {
        row.names(X) <- paste0("Feature", seq_len(nrow(X)))
    }

    ## Compute primary statistics
    
    n1n2 <- lapply(group.size, function(gs) gs * (ncol(X) - gs))
    
    if (is(X, "dgCMatrix")) {
        rank_res <- rank_matrix(Matrix::t(X))
    } else {
        rank_res <- rank_matrix(X)
    }

    ustat <- compute_ustat(rank_res$X_ranked, y, n1n2, group.size)
    pvals <- compute_pval(ustat, rank_res$ties, ncol(X), n1n2)
  

    
    results_list <- lapply(seq_along(ustat), function(i) {
  # Create a res_list for each i-th vector in ustat and pvals
    res_list <- list(
    pval = pvals[[i]],
    statistic = t(ustat[[i]])
  )
  
    tidy_results_reduced(res_list, row.names(X), levels(y[[i]]))
})

# results_list is now a list of the tidy_results_reduced outputs
return(results_list)
}
```

```{r}
grna_group_idxs <- sceptre_object@grna_assignments_raw$grna_group_idxs
response_matrix<-sceptre_object@response_matrix[[1]]
covariate <- sceptre_object@covariate_data_frame
```

```{r}
n_cells <- ncol(response_matrix)
n_genes <- nrow(response_matrix)
n_rows <- nrow(grna_assignment_matrix)
gc()
all_cells <- seq_len(n_cells)
```

## Estimate Propensity using logistic regression

```{r}
estimate_propensity <- function (grna_assignment_matrix, covariate) {
  
  estimated_prop <- matrix(NA, nrow = nrow(grna_assignment_matrix), ncol = ncol(grna_assignment_matrix))

# Loop through each row of the grna_assignment_matrix
for (i in 1:nrow(grna_assignment_matrix)) {
  
  # Extract the current row from the grna_assignment_matrix
  grna_row <- as.numeric(grna_assignment_matrix[i, ])
  
  # Fit logistic regression model using covariates and the current row
  glm_fit <- glm(grna_row ~ ., family = binomial(link = "logit"), data = covariate)
  
  # Predict the fitted means (estimated probabilities) for this row
  estimated_prop[i, ] <- predict(glm_fit, type = "response")
}
  return(estimated_prop)
}
```

## Permutation/Conditional resampling on gRNA assignment and combine the original matrix and permuted matrix as a big matrix

```{r}

resample_and_combine <- function(grna_assignment_matrix, n_permute) {
  propensity_matrix <- estimate_propensity(grna_assignment_matrix , covariate)
  
  propensity <- do.call(rbind, replicate(n_permute, propensity_matrix, simplify = FALSE))
  
  
    resampled_mat <- matrix(rbinom(n = length(propensity), 
                                  size = 1, 
                                  prob = as.vector(propensity)),
                           nrow = nrow(propensity), 
                           ncol = ncol(propensity))
  
    
    combined_mat <- rbind(grna_assignment_matrix, resampled_mat)

  return(combined_mat)
}

permute_and_combine <- function(grna_assignment_matrix, n_permute) {
  
  combined_mat <- grna_assignment_matrix  # Start with the original matrix
  
  for (i in 1:n_permute) {
    # Generate a permutation of the column indices
    permuted_indices <- sample(ncol(grna_assignment_matrix))
    
    # Apply the permutation to the columns
    permuted_mat <- grna_assignment_matrix[, permuted_indices]
    
    combined_mat <- rbind(combined_mat, permuted_mat)
  }
  
  return(combined_mat)
}

permutation_or_resampling <- function(grna_assignment_matrix, n_permute, use_resample=F){
  if(use_resample){
    return(resample_and_combine(grna_assignment_matrix, n_permute))
  } else{
    return(permute_and_combine(grna_assignment_matrix, n_permute))
  }
}
```

## Revised functions to calculate both original statistics and permuted statistics at a time

```{r}

slice_to_list <- function(large_matrix, n_permute) {
  # Initialize an empty list to store the smaller matrices
  sliced_matrices <- list()
  
  # Calculate the number of rows for each smaller matrix
  slice_size <- n_rows

 for (i in 1:(n_permute + 1)) {
    start_row <- (i - 1) * slice_size + 1
    end_row <- i * slice_size
    
    sliced_matrices[[i]] <- large_matrix[start_row:end_row, ]
  }
  
  return(sliced_matrices)
}

t_test <- function(response_matrix, grna_assignment_matrix, n_permute){
  
  grna_infected_cell_count <- grna_assignment_matrix%*%matrix(rep(1,n_cells),nrow=n_cells)
  
  mean_expression_trt <- grna_assignment_matrix%*%t(response_matrix)/as.vector(grna_infected_cell_count)
  
  mean_expression_squared_trt <- grna_assignment_matrix%*%t(response_matrix^2)/as.vector(grna_infected_cell_count)
  
  var_expression_trt <- mean_expression_squared_trt - mean_expression_trt^2
  
  grna_control_cell_count <- n_cells-grna_infected_cell_count
  
  mean_expression_control <- (1-grna_assignment_matrix)%*%t(response_matrix)/as.vector(grna_control_cell_count)
  
  mean_expression_squared_control <-(1-grna_assignment_matrix)%*%t(response_matrix^2)/as.vector(grna_control_cell_count)
  
  var_expression_control <- mean_expression_squared_control - mean_expression_control^2
  
  t_statistics <- (mean_expression_trt-mean_expression_control)/sqrt(var_expression_trt/as.vector(grna_infected_cell_count)+var_expression_control/as.vector(grna_control_cell_count))
  
  return(slice_to_list(t_statistics, n_permute))
}

wilcox_test <- function(response_matrix, grna_assignment_matrix, n_permute){
  
  response_dgC <- as(as.matrix(response_matrix),"dgCMatrix")

  grna_assignment_list <- split(grna_assignment_matrix, row(grna_assignment_matrix))
  
  wilcox_result <- wilcoxauc(response_dgC,grna_assignment_list)
  
  names(wilcox_result) <- rownames(grna_assignment_matrix_combined)
  
  combined_list <- list()
  
  for (i in 1:(n_permute+1)) {
  # Extract n_rows elements for each group and assign it to the new list
  combined_list[[i]] <- wilcox_result[((i - 1) * n_rows + 1):(i * n_rows)]
}
  return(combined_list)
}
```

```{r}
use_resample <- T
n_permute <- 5
grna_assignment_matrix_combined <- permutation_or_resampling(grna_assignment_matrix, n_permute, T)

```

```{r}
t_result <- t_test(response_matrix,grna_assignment_matrix_combined, n_permute)
```

```{r}
t_result[[6]][1:5,1:5]
```

```{r}
time_taken <- system.time({
 wilcox_result <- wilcox_test(response_matrix,grna_assignment_matrix_combined, n_permute)
})
time_taken["elapsed"]
```

```{r}
wilcox_result[[1]]$`SNP-1_1`
```

```{r}
rownames(response_matrix)
```

```{r}
library(rtracklayer)

gtf_data <- import("filtered_keep_gene.gtf")

gtf_data

```

```{r}
gene_mapping <- data.frame(
  gene_id = gtf_data$gene_id,
  gene_name = gtf_data$gene_name
)

# Remove any rows where gene_name is missing
gene_mapping <- na.omit(gene_mapping)

# Make sure there are no duplicates (multiple genes with the same name)
gene_mapping <- unique(gene_mapping)

# View the gene mapping
head(gene_mapping)
```

```{r}
text <- readLines("msig_50_table_immune_related.txt")  # Replace with your actual file path

# Combine all lines into a single string (in case it's multi-line)
combined_text <- paste(text, collapse = " ")

# Use a regular expression to extract all words starting with "HALLMARK"
hallmark_words <- unique(unlist(regmatches(combined_text, gregexpr("\\bHALLMARK\\w+", combined_text))))

# Print the extracted HALLMARK words
print(hallmark_words)
```

```{r}
gene_names<-rownames(response_matrix)
```

```{r}
gene_in_modules <- vector("logical", length(gene_names))

# Loop through each gene in gene_names
for (i in seq_along(gene_names)) {
  gene <- gene_names[i]
  
  # Check if the gene is in any module and return TRUE if it is found in any module
  gene_in_modules[i] <- any(sapply(modules_with_vectors, function(module) gene %in% module))
}

# Print the results
gene_in_modules
```

```{r}
sum(gene_in_modules==T)
```

```{r}
genes_in_modules_count <- vector("numeric", length(modules_with_vectors))

for (i in seq_along(modules_with_vectors)) {
  # Get the current module
  module <- modules_with_vectors[[i]]
  
  # Count how many genes in this module are present in gene_names
  genes_in_modules_count[i] <- sum(module %in% gene_names)
}

genes_in_modules_count
```
